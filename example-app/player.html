<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACR Player Interface</title>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: #222;
        }
        
        .panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .library-link {
            margin-left: 10px;
            font-size: 14px;
            color: #007bff;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
        }
        
        .library-link:hover {
            color: #0056b3;
            text-decoration: underline;
        }
        
        .library-link i {
            margin-right: 4px;
        }
        
        .player-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }
        
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        /* Player control styles */
        .player-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background-color: #f8f9fa;
            color: #333;
            font-size: 18px;
            margin: 0 5px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .control-btn:hover {
            background-color: #e9ecef;
            transform: scale(1.1);
        }
        
        .control-btn:disabled {
            color: #aaa;
            background-color: #f1f1f1;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .play-pause-btn {
            width: 60px;
            height: 60px;
            font-size: 22px;
            background-color: #007bff;
            color: white;
        }
        
        .play-pause-btn:hover {
            background-color: #0069d9;
        }
        
        .play-pause-btn:disabled {
            background-color: #99c5ff;
            color: #e6f0ff;
        }
        
        /* Song thumbnail styles */
        .song-thumbnail-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .song-thumbnail {
            width: 200px;
            height: 200px;
            object-fit: contain;
            border-radius: 5px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            background-color: #f1f1f1;
            display: inline-block;
        }
        
        .no-thumbnail {
            width: 200px;
            height: 200px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            background-color: #e9ecef;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            color: #6c757d;
            font-size: 40px;
        }
        
        .audio-settings {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .setting-btn {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid #ddd;
            background-color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }
        
        .setting-btn i {
            margin-right: 6px;
        }
        
        .setting-btn:hover {
            background-color: #f8f9fa;
            border-color: #bbb;
        }
        
        .setting-btn:disabled {
            color: #aaa;
            background-color: #f1f1f1;
            cursor: not-allowed;
        }
        
        .setting-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            font-weight: bold;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .player-info {
            margin-top: 20px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            position: relative;  /* Add relative positioning to contain absolute elements */
        }
        
        .library-button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 5px;
        }
        
        .library-button:hover:not(:disabled) {
            background-color: #218838;
        }
        
        .library-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.65;
        }
        
        .selection-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .state-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .state-playing {
            background-color: #28a745;
        }
        
        .state-paused {
            background-color: #ffc107;
        }
        
        .state-stopped {
            background-color: #dc3545;
        }
        
        .state-unknown {
            background-color: #6c757d;
        }
        
        .now-playing {
            margin-top: 20px;
        }
        
        .progress-container {
            height: 5px;
            background-color: #e9ecef;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
            cursor: pointer; /* Add cursor pointer to indicate it's clickable */
        }
        
        .progress-bar {
            height: 100%;
            background-color: #007bff;
            border-radius: 3px;
            width: 0%;
        }
        
        /* Queue panel styles */
        .badge {
            display: inline-block;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: normal;
            background-color: #f8f9fa;
            border-radius: 12px;
            color: #6c757d;
            margin-left: 5px;
        }
        
        .queue-controls {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 15px;
            gap: 10px;
        }
        
        .secondary-btn {
            padding: 6px 12px;
            font-size: 14px;
            background-color: #6c757d;
        }
        
        .secondary-btn:hover {
            background-color: #5a6268;
        }
        
        .danger-btn {
            background-color: #dc3545;
        }
        
        .danger-btn:hover {
            background-color: #c82333;
        }
        
        .queue-container {
            border: 1px solid #e9ecef;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .queue-item {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #e9ecef;
            align-items: center;
        }
        
        .queue-item:last-child {
            border-bottom: none;
        }
        
        .queue-item.current {
            background-color: #e3f2fd;
        }
        
        .queue-item-info {
            flex-grow: 1;
        }
        
        .queue-item-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .queue-item-artist {
            color: #6c757d;
            font-size: 14px;
        }
        
        .queue-item-actions {
            display: flex;
            gap: 5px;
        }
        
        .queue-action-btn {
            padding: 4px 8px;
            font-size: 12px;
            background-color: transparent;
            color: #6c757d;
            border: 1px solid #ced4da;
        }
        
        .queue-action-btn:hover {
            background-color: #e9ecef;
            color: #495057;
        }
        
        .queue-message {
            padding: 20px;
            text-align: center;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ACR Player Interface</h1>
        
        <div class="panel">
            <h2>Player Selection</h2>
            
            <div class="form-group">
                <label for="player-select">Select Player</label>
                <select id="player-select">
                    <option value="">Loading players...</option>
                </select>
            </div>
            
            <div class="selection-controls">
                <button id="refresh-btn"><i class="fas fa-sync-alt"></i> Refresh Player List</button>
                <button id="library-button" class="library-button" disabled>
                    <i class="fas fa-book"></i> Library
                </button>
                <div class="websocket-status" id="websocket-status" style="display: inline-flex; align-items: center; margin-left: 10px; font-size: 12px; color: #666;">
                    <div class="indicator disconnected" style="width: 8px; height: 8px; border-radius: 50%; margin-right: 5px; background-color: #dc3545;"></div>
                    <span>Disconnected</span>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Player Controls</h2>
            
            <div class="player-controls">
                <button id="prev-btn" class="control-btn" disabled title="Previous">
                    <i class="fas fa-step-backward"></i>
                </button>
                <button id="play-pause-btn" class="control-btn play-pause-btn" disabled title="Play/Pause">
                    <i class="fas fa-play"></i>
                </button>
                <button id="stop-btn" class="control-btn" disabled title="Stop">
                    <i class="fas fa-stop"></i>
                </button>
                <button id="next-btn" class="control-btn" disabled title="Next">
                    <i class="fas fa-step-forward"></i>
                </button>
            </div>
            
            <div class="audio-settings">
                <button id="toggle-shuffle-btn" class="setting-btn" disabled>
                    <i class="fas fa-random"></i> Shuffle: Off
                </button>
                <button id="loop-mode-btn" class="setting-btn" disabled>
                    <i class="fas fa-times"></i> Loop: None
                </button>
            </div>
            
            <div class="player-info">
                <h3>Current Player:</h3>
                <div id="current-player-info">No player selected</div>
                
                <div class="now-playing">
                    <h3>Now Playing:</h3>
                    <div id="now-playing-info">Nothing playing</div>
                    <div class="song-thumbnail-container">
                        <img id="song-thumbnail" class="song-thumbnail" src="" alt="Song Thumbnail" style="display: none;">
                        <div id="no-thumbnail" class="no-thumbnail">?</div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- New section for queue display -->
        <div class="panel" id="queue-panel" style="display: none;">
            <h2>Queue <span id="queue-count" class="badge">(0)</span></h2>
            <div class="queue-controls">
                <button id="refresh-queue-btn" class="secondary-btn">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
                <button id="clear-queue-btn" class="secondary-btn danger-btn">
                    <i class="fas fa-trash"></i> Clear Queue
                </button>
            </div>
            <div class="queue-container" id="queue-container">
                <div class="queue-message">Loading queue...</div>
            </div>
        </div>
    </div>
    
    <script>
        // DOM Elements
        const playerSelect = document.getElementById('player-select');
        const refreshBtn = document.getElementById('refresh-btn');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const loopModeBtn = document.getElementById('loop-mode-btn');
        const toggleShuffleBtn = document.getElementById('toggle-shuffle-btn');
        const currentPlayerInfo = document.getElementById('current-player-info');
        const nowPlayingInfo = document.getElementById('now-playing-info');
        const progressBar = document.getElementById('progress-bar');
        const websocketStatus = document.getElementById('websocket-status');
        const libraryBtn = document.getElementById('library-button');
        const songThumbnail = document.getElementById('song-thumbnail');
        const noThumbnail = document.getElementById('no-thumbnail');
        
        // Queue-related DOM elements
        const queuePanel = document.getElementById('queue-panel');
        const queueCount = document.getElementById('queue-count');
        const queueContainer = document.getElementById('queue-container');
        const refreshQueueBtn = document.getElementById('refresh-queue-btn');
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        
        // Configuration
        const CONFIG = {
            pollingInterval: 30000, // Time in milliseconds between updates (30 seconds)
            fastUpdateAfterCommand: 300, // Time to wait for quick update after sending a command
            wsReconnectInterval: 5000,  // Time to wait before attempting to reconnect WebSocket
            progressUpdateInterval: 500  // Time in milliseconds between progress bar updates (0.5 seconds)
        };
        
        // API Endpoints
        const API_BASE = '/api';
        let updateInterval = null;
        let currentData = null;
        let currentPlayerName = null; // Track the current player name for commands
        let socket = null; // WebSocket connection
        let reconnectInterval = null; // Interval for WebSocket reconnection attempts
        let progressInterval = null; // Interval for auto progress updates
        let lastProgressUpdate = null; // Timestamp of the last progress update
        let playerCapabilities = { // Default capabilities (all disabled)
            canPlay: false,
            canPause: false,
            canStop: false,
            canPrevious: false,
            canNext: false,
            canSeek: false,
            hasQueue: false,
            canShuffle: false,
            canLoop: false
        };

        // Extract player capabilities from response data
        function extractPlayerCapabilities(data) {
            const capabilities = {
                canPlay: false,
                canPause: false,
                canStop: false,
                canPrevious: false,
                canNext: false,
                canSeek: false,
                hasQueue: false,
                canShuffle: false,
                canLoop: false
            };
            
            if (!data || !data.player) {
                return capabilities;
            }
            
            // Check if player metadata contains capabilities information
            if (data.player.metadata && data.player.metadata.capabilities) {
                const caps = data.player.metadata.capabilities;
                capabilities.canPlay = caps.includes('play');
                capabilities.canPause = caps.includes('pause');
                capabilities.canStop = caps.includes('stop');
                capabilities.canPrevious = caps.includes('previous');
                capabilities.canNext = caps.includes('next');
                capabilities.canSeek = caps.includes('seek');
                capabilities.hasQueue = caps.includes('queue');
                capabilities.canShuffle = caps.includes('shuffle') || caps.includes('random');
                capabilities.canLoop = caps.includes('loop');
                return capabilities;
            }
            
            // Alternative: Check if capabilities are directly in player info
            if (data.player.capabilities) {
                const caps = data.player.capabilities;
                capabilities.canPlay = caps.includes('play');
                capabilities.canPause = caps.includes('pause');
                capabilities.canStop = caps.includes('stop');
                capabilities.canPrevious = caps.includes('previous');
                capabilities.canNext = caps.includes('next');
                capabilities.canSeek = caps.includes('seek');
                capabilities.hasQueue = caps.includes('queue');
                capabilities.canShuffle = caps.includes('shuffle') || caps.includes('random');
                capabilities.canLoop = caps.includes('loop');
                return capabilities;
            }
            
            // Fallback: If no explicit capabilities, infer from player state
            // Most players will support basic operations
            if (data.player.is_active) {
                capabilities.canPlay = true;
                capabilities.canPause = true;
                capabilities.canStop = true;
                
                // Assume track navigation if a song is playing
                if (data.song) {
                    capabilities.canPrevious = true;
                    capabilities.canNext = true;
                }
                
                // If player has shuffle or loop state, assume it can change these
                if (typeof data.shuffle === 'boolean') {
                    capabilities.canShuffle = true;
                }
                
                if (data.loop_mode) {
                    capabilities.canLoop = true;
                }
                
                // If position is reported, assume seeking is possible
                if (data.position !== undefined && data.position !== null) {
                    capabilities.canSeek = true;
                }
                
                // If the player has a library, assume it also has a queue
                if (data.player.has_library) {
                    capabilities.hasQueue = true;
                }
            }
            
            return capabilities;
        }

        // Event Handlers
        playerSelect.addEventListener('change', switchPlayer); // Switch player immediately on selection
        refreshBtn.addEventListener('click', fetchPlayers);
        playPauseBtn.addEventListener('click', togglePlayPause);
        stopBtn.addEventListener('click', () => sendCommand('stop'));
        prevBtn.addEventListener('click', () => sendCommand('previous'));
        nextBtn.addEventListener('click', () => sendCommand('next'));
        loopModeBtn.addEventListener('click', cycleLoopMode);
        toggleShuffleBtn.addEventListener('click', toggleShuffle);
        libraryBtn.addEventListener('click', openPlayerLibrary);
        
        // Queue control event handlers
        refreshQueueBtn.addEventListener('click', fetchQueue);
        clearQueueBtn.addEventListener('click', clearQueue);
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initialize);
        
        function initialize() {
            fetchPlayers();
            fetchCurrentPlayer();
            
            // Set up periodic updates using the configured polling interval
            updateInterval = setInterval(fetchCurrentPlayer, CONFIG.pollingInterval);
            
            // Initialize WebSocket connection
            setupWebSocket();
            
            // Set up progress bar click handler for seeking
            setupProgressBarClickHandler();
        }
        
        // Set up click handler for progress bar seeking
        function setupProgressBarClickHandler() {
            const progressContainer = document.querySelector('.progress-container');
            
            progressContainer.addEventListener('click', function(event) {
                // Only allow seeking if we have a song playing and the player supports seeking
                if (!currentData || !currentData.song || !currentData.song.duration || !playerCapabilities.canSeek) {
                    return;
                }
                
                // Calculate the position to seek to based on the click position
                const rect = this.getBoundingClientRect();
                const clickOffset = event.clientX - rect.left;
                const clickPercentage = clickOffset / rect.width;
                const seekPosition = currentData.song.duration * clickPercentage;
                
                // Send the seek command
                console.log(`Seeking to position: ${formatTime(seekPosition)} (${Math.round(clickPercentage * 100)}%)`);
                seekToPosition(seekPosition);
            });
        }
        
        // Send seek command to player
        async function seekToPosition(position) {
            try {
                const seekCommand = `seek:${Math.floor(position)}`;
                await sendCommand(seekCommand);
                
                // Update local position immediately for smoother UI
                if (currentData && currentData.song) {
                    currentData.position = position;
                    updateProgressBar();
                }
            } catch (error) {
                console.error('Error seeking to position:', error);
            }
        }
        
        // Fetch available players
        async function fetchPlayers() {
            try {
                const response = await fetch(`${API_BASE}/players`);
                const data = await response.json();
                
                if (data.players && Array.isArray(data.players)) {
                    updatePlayerDropdown(data.players);
                } else {
                    console.error('Invalid players data structure:', data);
                }
            } catch (error) {
                console.error('Failed to fetch players:', error);
            }
        }
        
        // Update player dropdown with available players
        function updatePlayerDropdown(players) {
            playerSelect.innerHTML = '';
            
            if (players.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No players available';
                playerSelect.appendChild(option);
                return;
            }
            
            // Add a default option for the active player
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Default (Active Player)';
            playerSelect.appendChild(defaultOption);
            
            // Find the active player for library button state
            const activePlayer = players.find(player => player.is_active);
            if (activePlayer) {
                // Update library button state based on active player
                const hasLibrary = activePlayer.has_library;
                libraryBtn.disabled = !hasLibrary;
                
                // Mark the default option as selected
                defaultOption.selected = true;
                currentPlayerName = null; // Use the default active player
            }
            
            // Add remaining players to dropdown
            players.forEach(player => {
                const option = document.createElement('option');
                option.value = player.name;
                option.textContent = player.name;
                playerSelect.appendChild(option);
            });
        }
        
        // Switch to selected player
        function switchPlayer() {
            const selectedPlayer = playerSelect.value;
            
            if (!selectedPlayer) {
                // Selected the default "active player" option
                currentPlayerName = null;
            } else {
                // Selected a specific player
                currentPlayerName = selectedPlayer;
            }
            
            // Update UI to reflect the change
            fetchCurrentPlayer();
            
            // Update WebSocket subscription for the new player
            subscribeToPlayerEvents();
            
            // Reset the queue display
            queueContainer.innerHTML = '<div class="queue-message">Loading queue...</div>';
            queueContainer.removeAttribute('data-loaded');
            // Queue will be fetched when capabilities are updated
        }
        
        // Toggle play/pause based on current state
        function togglePlayPause() {
            if (!currentData) return;
            
            // Check state case-insensitively to handle different API response formats
            const isPlaying = currentData.state && 
                             currentData.state.toLowerCase() === 'playing';
            
            const command = isPlaying ? 'pause' : 'play';
            console.log(`Sending command: ${command} based on state: ${currentData.state}`);
            sendCommand(command);
        }
        
        // Cycle through loop modes: None -> Track -> Playlist -> None
        function cycleLoopMode() {
            if (!currentData) return;
            
            let nextMode;
            // Check the loop mode value case-insensitively since API might use different cases
            const currentMode = (currentData.loop_mode || '').toLowerCase();
            
            console.log(`Current loop mode: ${currentMode}`);
            
            switch(currentMode) {
                case 'none':
                case 'no':
                    nextMode = 'track';
                    break;
                case 'track':
                case 'song':
                    nextMode = 'playlist';
                    break;
                case 'playlist':
                default:
                    nextMode = 'none';
                    break;
            }
            
            console.log(`Setting new loop mode: ${nextMode}`);
            sendCommand(`set_loop:${nextMode}`);
        }
        
        // Fetch current player and now playing information
        async function fetchCurrentPlayer() {
            try {
                const response = await fetch(`${API_BASE}/now-playing`);
                const data = await response.json();
                
                currentData = data;
                updatePlayerInfo(data);
                updateNowPlaying(data);
                updateControlButtons(data);
            } catch (error) {
                console.error('Failed to fetch current player:', error);
            }
        }
        
        // Update player info display
        function updatePlayerInfo(data) {
            if (data.player && data.player.name) {
                const stateClass = `state-${data.state.toLowerCase()}`;
                currentPlayerInfo.innerHTML = `
                    <div>
                        <span class="state-indicator ${stateClass}"></span>
                        <strong>${data.player.name}</strong> (${data.state})
                    </div>
                `;

                // Update Library button link if player has a library
                const hasLibrary = data.player.has_library;
                libraryBtn.disabled = !hasLibrary;
                if (hasLibrary) {
                    libraryBtn.href = `library.html?player=${encodeURIComponent(data.player.name)}`;
                }
            } else {
                currentPlayerInfo.textContent = 'No active player';
            }
        }
        
        // Update now playing information
        function updateNowPlaying(data) {
            if (data.song) {
                const song = data.song;
                const position = data.position ? formatTime(data.position) : '0:00';
                const duration = song.duration ? formatTime(song.duration) : '0:00';
                
                // Update progress bar
                if (song.duration && data.position) {
                    const percentage = (data.position / song.duration) * 100;
                    progressBar.style.width = `${percentage}%`;
                } else {
                    progressBar.style.width = '0%';
                }
                
                nowPlayingInfo.innerHTML = `
                    <div><strong>Title:</strong> ${song.title || 'Unknown'}</div>
                    <div><strong>Artist:</strong> ${song.artist || 'Unknown'}</div>
                    ${song.album ? `<div><strong>Album:</strong> ${song.album}</div>` : ''}
                    <div><strong>Position:</strong> ${position} / ${duration}</div>
                `;

                // Update song thumbnail
                if (song.thumbnail) {
                    songThumbnail.src = song.thumbnail;
                    songThumbnail.style.display = 'inline-block';
                    noThumbnail.style.display = 'none';
                } else {
                    songThumbnail.style.display = 'none';
                    noThumbnail.style.display = 'inline-flex';
                }
                
                // Start auto progress updates if the player is playing
                if (data.state && data.state.toLowerCase() === 'playing') {
                    // Reset the timestamp to now whenever we get a real update
                    lastProgressUpdate = Date.now();
                    startAutoProgress();
                } else {
                    stopAutoProgress();
                }
            } else {
                nowPlayingInfo.textContent = 'Nothing playing';
                progressBar.style.width = '0%';
                songThumbnail.style.display = 'none';
                noThumbnail.style.display = 'inline-flex';
                stopAutoProgress();
            }
        }
        
        // Update control buttons based on available capabilities and current state
        function updateControlButtons(data) {
            // Extract player capabilities
            playerCapabilities = extractPlayerCapabilities(data);
            
            // Check playback state
            const isPlaying = data.state && data.state.toLowerCase() === 'playing';
            const isPaused = data.state && data.state.toLowerCase() === 'paused'; 
            const isPlayingOrPaused = isPlaying || isPaused;
            
            // Enable/disable buttons based on player capabilities
            playPauseBtn.disabled = !(playerCapabilities.canPlay || playerCapabilities.canPause);
            stopBtn.disabled = !playerCapabilities.canStop || !isPlayingOrPaused;
            prevBtn.disabled = !playerCapabilities.canPrevious;
            nextBtn.disabled = !playerCapabilities.canNext;
            loopModeBtn.disabled = !playerCapabilities.canLoop;
            toggleShuffleBtn.disabled = !playerCapabilities.canShuffle;
            
            // Enable/disable Library button based on whether player has a library
            const hasLibrary = data.player && data.player.has_library;
            libraryBtn.disabled = !hasLibrary;
            
            // Show or hide queue panel based on whether player supports queue
            if (playerCapabilities.hasQueue) {
                queuePanel.style.display = 'block';
                // Fetch queue if it's now visible and we haven't already
                if (!queueContainer.hasAttribute('data-loaded')) {
                    fetchQueue();
                }
            } else {
                queuePanel.style.display = 'none';
            }
            
            // Update play/pause button icon based on state
            if (playPauseBtn.disabled === false) {
                // Update play/pause button icon
                if (isPlaying) {
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    playPauseBtn.title = 'Pause';
                } else {
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    playPauseBtn.title = 'Play';
                }
            }
            
            if (loopModeBtn.disabled === false) {
                // Update loop mode button
                let loopIcon, loopText;
                const loopMode = (data.loop_mode || '').toLowerCase();
                
                switch(loopMode) {
                    case 'track':
                    case 'song':
                        loopIcon = 'fa-redo';
                        loopText = 'Loop: Track';
                        break;
                    case 'playlist':
                        loopIcon = 'fa-retweet';
                        loopText = 'Loop: Playlist';
                        break;
                    case 'none':
                    case 'no':
                    default:
                        loopIcon = 'fa-times';
                        loopText = 'Loop: None';
                        break;
                }
                loopModeBtn.innerHTML = `<i class="fas ${loopIcon}"></i> ${loopText}`;
                loopModeBtn.classList.toggle('active', loopMode !== 'none' && loopMode !== 'no');
            }
            
            if (toggleShuffleBtn.disabled === false) {
                // Update shuffle button state
                toggleShuffleBtn.classList.toggle('active', data.shuffle);
                toggleShuffleBtn.innerHTML = `<i class="fas fa-random"></i> Shuffle: ${data.shuffle ? 'On' : 'Off'}`;
            }
            
            // Log the current capabilities
            console.log('Player capabilities:', playerCapabilities);
        }
        
        // Send command to player
        async function sendCommand(command) {
            try {
                // Build the URL based on whether we're using a specific player or the active player
                let url;
                if (currentPlayerName) {
                    // Send to specific player
                    url = `${API_BASE}/player/${currentPlayerName}/command/${command}`;
                } else {
                    // Send to active player (default)
                    url = `${API_BASE}/player/active/command/${command}`;
                }
                
                console.log(`Sending command to: ${url}`);
                const response = await fetch(url, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    // Update UI after command was successfully sent
                    setTimeout(fetchCurrentPlayer, CONFIG.fastUpdateAfterCommand);
                } else {
                    console.error('Failed to send command:', await response.text());
                }
            } catch (error) {
                console.error('Error sending command:', error);
            }
        }
        
        // Toggle shuffle state
        async function toggleShuffle() {
            try {
                // First fetch the current state to toggle it
                const response = await fetch(`${API_BASE}/now-playing`);
                const data = await response.json();
                
                if (data.shuffle !== undefined) {
                    // Send the opposite of the current shuffle state
                    await sendCommand(`set_random:${!data.shuffle}`);
                }
            } catch (error) {
                console.error('Error toggling shuffle:', error);
            }
        }
        
        // Format time in seconds to MM:SS or HH:MM:SS
        function formatTime(seconds) {
            if (seconds === undefined || seconds === null) return '00:00';
            
            seconds = Math.floor(seconds);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }
        
        // Setup WebSocket connection
        function setupWebSocket() {
            // Close any existing connection first
            if (socket) {
                console.log('Closing existing WebSocket connection before creating a new one');
                socket.onclose = null; // Remove the event handler to avoid reconnect loops
                if (socket.readyState !== WebSocket.CLOSED && socket.readyState !== WebSocket.CLOSING) {
                    socket.close();
                }
                socket = null;
            }
            
            // Clear any existing reconnect interval
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
            
            // Create WebSocket connection
            const wsUrl = `ws://${window.location.hostname}:${window.location.port || 1080}/api/events`;
            console.log(`Connecting to WebSocket at: ${wsUrl}`);
            
            try {
                socket = new WebSocket(wsUrl);
                
                socket.onopen = function() {
                    console.log('WebSocket connected');
                    websocketStatus.querySelector('.indicator').style.backgroundColor = '#28a745';
                    websocketStatus.querySelector('span').textContent = 'Connected';
                    
                    // Subscribe to events for the current player
                    subscribeToPlayerEvents();
                    
                    // Clear any reconnect interval
                    if (reconnectInterval) {
                        clearInterval(reconnectInterval);
                        reconnectInterval = null;
                    }
                };
                
                socket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('WebSocket message received:', data);
                        
                        // Handle welcome message
                        if (data.type === 'welcome' || data.type === 'subscription_updated') {
                            console.log('WebSocket:', data.message);
                            return;
                        }
                        
                        // Process player events
                        handlePlayerEvent(data);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                socket.onclose = function(event) {
                    console.log(`WebSocket disconnected (code: ${event.code}, reason: ${event.reason || 'No reason given'})`);
                    websocketStatus.querySelector('.indicator').style.backgroundColor = '#dc3545';
                    websocketStatus.querySelector('span').textContent = 'Disconnected';
                    
                    // Attempt to reconnect, but only if not closing intentionally
                    if (event.code !== 1000 && event.code !== 1001) {
                        console.log('Scheduling reconnection attempt...');
                        if (!reconnectInterval) {
                            reconnectInterval = setTimeout(() => {
                                console.log('Attempting to reconnect WebSocket...');
                                setupWebSocket();
                            }, CONFIG.wsReconnectInterval);
                        }
                    }
                };
                
                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    // Error handling is managed by onclose handler
                };
            } catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                websocketStatus.querySelector('.indicator').style.backgroundColor = '#dc3545';
                websocketStatus.querySelector('span').textContent = 'Connection Failed';
                
                // Schedule reconnection attempt
                if (!reconnectInterval) {
                    reconnectInterval = setTimeout(setupWebSocket, CONFIG.wsReconnectInterval);
                }
            }
        }
        
        // Subscribe to events for the current player
        function subscribeToPlayerEvents() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.warn('Cannot subscribe to player events: WebSocket not open');
                return;
            }
            
            // Get the current player name to subscribe to
            const playerToSubscribe = currentPlayerName || 'active';
            
            // Create subscription message - using proper format expected by the server
            const subscription = {
                "players": playerToSubscribe === 'active' ? null : [playerToSubscribe],
                "event_types": [
                    "state_changed",
                    "song_changed",
                    "position_changed",
                    "loop_mode_changed", 
                    "shuffle_changed",
                    "capabilities_changed",
                    "metadata_changed"
                ]
            };
            
            console.log(`Subscribing to events for player: ${playerToSubscribe}`, subscription);
            socket.send(JSON.stringify(subscription));
        }
        
        // Handle player events received from WebSocket
        function handlePlayerEvent(data) {
            // Get the event source (player name)
            const source = data.source || {};
            const playerName = source.player_name;
            
            // Check if this event is for our current player
            const isForCurrentPlayer = 
                !currentPlayerName || // We're using the active player
                playerName === currentPlayerName || // Event is for our selected player
                (source.is_active && !currentPlayerName); // Event is for the active player and we're using the active player
                
            if (!isForCurrentPlayer) {
                return; // Ignore events for other players
            }
            
            console.log(`Processing event for player: ${playerName}`);
            
            // Only process events with the type field (snake_case format)
            if (data.type) {
                switch(data.type) {
                    case 'state_changed':
                        processStateChange(data.state);
                        break;
                    case 'song_changed':
                        processSongChange(data.song);
                        break;
                    case 'position_changed':
                        processPositionChange(data.position);
                        break;
                    case 'loop_mode_changed':
                        processLoopModeChange(data.mode);
                        break;
                    case 'shuffle_changed':
                        processShuffleChange(data.shuffle);
                        break;
                    case 'capabilities_changed':
                        processCapabilitiesChange(data);
                        break;
                    default:
                        console.log(`Unhandled event type: ${data.type}`);
                }
                return;
            }
            
            // If we get here, log the unrecognized format
            console.log('Unknown event format:', data);
        }
        
        // Process state change events
        function processStateChange(newState) {
            if (!newState) return;
            
            console.log(`Player state changed to: ${newState}`);
            
            // Update UI for state change
            if (currentData) {
                currentData.state = newState;
                updatePlayerInfo(currentData);
                updateControlButtons(currentData);
                
                // Start or stop auto progress updates based on state
                if (newState.toLowerCase() === 'playing') {
                    lastProgressUpdate = Date.now(); // Reset timestamp on play
                    startAutoProgress();
                } else {
                    stopAutoProgress();
                }
            } else {
                // If we don't have current data, fetch everything
                fetchCurrentPlayer();
            }
        }
        
        // Process song change events
        function processSongChange(songData) {
            if (!songData) return;
            
            console.log(`Song changed: ${songData.title || 'Unknown'} by ${songData.artist || 'Unknown'}`);
            
            // Update song information
            if (currentData) {
                currentData.song = songData;
                // Reset position to 0 for new song if not provided
                if (!songData.position) {
                    currentData.position = 0;
                }
                updateNowPlaying(currentData);
                
                // Reset and restart auto progress for the new song if playing
                if (currentData.state && currentData.state.toLowerCase() === 'playing') {
                    lastProgressUpdate = Date.now();
                    startAutoProgress();
                }
            } else {
                fetchCurrentPlayer();
            }
        }
        
        // Process position change events
        function processPositionChange(positionData) {
            if (!positionData) return;
            
            console.log('Processing position update with data:', positionData);
            
            let newPosition;
            
            // Handle the different possible formats of position data:
            if (typeof positionData === 'object') {
                // Format 1: {position: number, duration: number}
                if (positionData.position !== undefined) {
                    newPosition = positionData.position;
                }
                // Format 2: direct number value in the object (server oddity)
                else {
                    const positionValue = Object.values(positionData)[0];
                    if (typeof positionValue === 'number') {
                        newPosition = positionValue;
                    }
                }
            }
            // Format 3: direct number value
            else if (typeof positionData === 'number') {
                newPosition = positionData;
            }
            
            // If we couldn't determine a valid position, return
            if (newPosition === undefined || isNaN(newPosition)) {
                console.warn('Could not determine valid position from event data:', positionData);
                return;
            }
            
            // Only log position changes every 5 seconds to reduce console spam
            if (Math.floor(newPosition) % 5 === 0) {
                console.log(`Position changed: ${formatTime(newPosition)}`);
            }
            
            // Update position in UI
            if (currentData) {
                currentData.position = newPosition;
                lastProgressUpdate = Date.now(); // Reset timestamp on position update
                updateProgressBar(); // Just update the progress bar, not the whole UI
                
                // Check if player is playing and restart the progress interval if it is
                const isPlaying = currentData.state && currentData.state.toLowerCase() === 'playing';
                console.log(`Player state is: ${currentData.state} (isPlaying: ${isPlaying})`);
                
                if (isPlaying) {
                    console.log(`Position update for playing track - resetting auto progress with position: ${formatTime(newPosition)}`);
                    stopAutoProgress(); // Make sure any existing interval is cleared
                    startAutoProgress(); // Start a new interval
                }
            }
        }
        
        // Process loop mode change events
        function processLoopModeChange(newLoopMode) {
            if (!newLoopMode) return;
            
            console.log(`Loop mode changed: ${newLoopMode}`);
            
            // Update loop mode in UI
            if (currentData) {
                currentData.loop_mode = newLoopMode;
                updatePlayerInfo(currentData);
                updateControlButtons(currentData);
            } else {
                fetchCurrentPlayer();
            }
        }
        
        // Process shuffle change events
        function processShuffleChange(newShuffle) {
            console.log(`Shuffle mode changed: ${newShuffle}`);
            
            // Update shuffle state in UI
            if (currentData) {
                currentData.shuffle = newShuffle;
                updatePlayerInfo(currentData);
                updateControlButtons(currentData);
            } else {
                fetchCurrentPlayer();
            }
        }
        
        // Process capabilities change events
        function processCapabilitiesChange(data) {
            console.log('Player capabilities changed:', data);
            
            // Handle capabilities directly if they are provided in the event
            if (data.capabilities && Array.isArray(data.capabilities)) {
                const caps = data.capabilities;
                
                // Update our capability object
                playerCapabilities.canPlay = caps.includes('play');
                playerCapabilities.canPause = caps.includes('pause');
                playerCapabilities.canStop = caps.includes('stop');
                playerCapabilities.canPrevious = caps.includes('previous');
                playerCapabilities.canNext = caps.includes('next');
                playerCapabilities.canSeek = caps.includes('seek');
                playerCapabilities.hasQueue = caps.includes('queue');
                playerCapabilities.canShuffle = caps.includes('shuffle') || caps.includes('random');
                playerCapabilities.canLoop = caps.includes('loop');
                
                console.log('Updated capabilities from event:', playerCapabilities);
                
                // Update UI with new capabilities
                if (currentData) {
                    updateControlButtons(currentData);
                }
            } else {
                // If capabilities not directly provided, fetch from server
                console.log('Fetching updated capabilities from server');
                fetchCurrentPlayer();
            }
        }
        
        // Clean up resources when page is unloaded
        window.addEventListener('beforeunload', function() {
            // Close WebSocket connection cleanly
            if (socket) {
                socket.onclose = null; // Prevent reconnection attempts
                socket.close();
                socket = null;
            }
            
            // Clear any reconnection timers
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
            
            // Clear polling interval
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            
            // Clear progress update interval
            stopAutoProgress();
        });
        
        // Start auto progress updates for the progress bar
        function startAutoProgress() {
            // Stop any existing interval first
            stopAutoProgress();
            
            // Only start if we have current data and a song is playing
            if (!currentData || !currentData.song || !currentData.song.duration) {
                console.log('Cannot start auto progress: missing song data or duration');
                return;
            }
            
            const isPlaying = currentData.state && currentData.state.toLowerCase() === 'playing';
            if (!isPlaying) {
                console.log('Cannot start auto progress: player is not in playing state');
                return;
            }
            
            console.log(`Starting auto progress updates from position: ${formatTime(currentData.position || 0)}`);
            
            // Ensure position is initialized
            if (currentData.position === undefined || currentData.position === null) {
                console.log('Initializing position to 0 as it was undefined');
                currentData.position = 0;
            }
            
            // Reset the timestamp to now
            lastProgressUpdate = Date.now();
            
            // Create a new interval
            progressInterval = setInterval(() => {
                if (!currentData || !currentData.song || !currentData.song.duration) {
                    console.warn('Progress update: missing song data, stopping auto-updates');
                    stopAutoProgress();
                    return;
                }
                
                // Make sure position is defined
                if (currentData.position === undefined || currentData.position === null) {
                    currentData.position = 0;
                }
                
                // Calculate how much time has passed since the last position update
                const now = Date.now();
                const elapsedSeconds = (now - lastProgressUpdate) / 1000;
                lastProgressUpdate = now;
                
                // Add the elapsed time to the current position
                currentData.position += elapsedSeconds;
                
                // Check if we've reached the end of the song
                if (currentData.position >= currentData.song.duration) {
                    // Stop at the end of the song
                    currentData.position = currentData.song.duration;
                    
                    // Force an update of player state from server when we reach the end
                    console.log('Track reached the end, fetching current player state from server');
                    fetchCurrentPlayer();
                    
                    // Don't stop the timer yet - it will be managed based on the updated state
                }
                
                // Update the progress bar and position display
                updateProgressBar();
                
            }, CONFIG.progressUpdateInterval);
        }
        
        // Stop auto progress updates
        function stopAutoProgress() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }
        
        // Update only the progress bar and position text without updating the entire UI
        function updateProgressBar() {
            if (!currentData || !currentData.song || !currentData.position) {
                return;
            }
            
            const song = currentData.song;
            
            // Update progress bar
            if (song.duration) {
                const percentage = (currentData.position / song.duration) * 100;
                progressBar.style.width = `${percentage}%`;
                
                // Update position text if it exists in the DOM
                const positionElement = nowPlayingInfo.querySelector('div:last-child');
                if (positionElement) {
                    const position = formatTime(currentData.position);
                    const duration = formatTime(song.duration);
                    positionElement.innerHTML = `<strong>Position:</strong> ${position} / ${duration}`;
                }
            }
        }
        
        // Open player library
        function openPlayerLibrary() {
            if (!currentData || !currentData.player || !currentData.player.name) {
                console.warn('No player selected to open library');
                return;
            }
            
            const playerName = currentPlayerName || 'active';
            const libraryUrl = `library.html?player=${encodeURIComponent(playerName)}`;
            console.log(`Navigating to library: ${libraryUrl}`);
            window.location.href = libraryUrl;
        }
        
        // Fetch the queue for the current player
        async function fetchQueue() {
            try {
                // Display loading message
                queueContainer.innerHTML = '<div class="queue-message">Loading queue...</div>';
                
                // Reset the loaded flag
                queueContainer.removeAttribute('data-loaded');
                
                // Determine which player to fetch the queue for
                const playerToFetch = currentPlayerName || 'active';
                const apiUrl = `${API_BASE}/player/${playerToFetch}/queue`;
                
                console.log(`Fetching queue from: ${apiUrl}`);
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    console.error(`Failed to fetch queue: ${response.status} ${response.statusText}`);
                    queueContainer.innerHTML = '<div class="queue-message">Failed to load queue</div>';
                    return;
                }
                
                const data = await response.json();
                displayQueue(data);
                
                // Mark as loaded
                queueContainer.setAttribute('data-loaded', 'true');
            } catch (error) {
                console.error('Error fetching queue:', error);
                queueContainer.innerHTML = '<div class="queue-message">Failed to load queue</div>';
            }
        }
        
        // Display the queue data
        function displayQueue(data) {
            // Validate data
            if (!data || !data.queue || !Array.isArray(data.queue)) {
                queueContainer.innerHTML = '<div class="queue-message">No queue items</div>';
                queueCount.textContent = '(0)';
                return;
            }
            
            // Update queue count badge
            queueCount.textContent = `(${data.queue.length})`;
            
            // If queue is empty
            if (data.queue.length === 0) {
                queueContainer.innerHTML = '<div class="queue-message">Queue is empty</div>';
                return;
            }
            
            // Build queue items
            let queueHtml = '';
            
            data.queue.forEach((track, index) => {
                // Check if this is the currently playing track
                const isCurrent = currentData && currentData.song && 
                                  currentData.song.uri === track.uri;
                
                const trackTitle = track.name || 'Unknown';
                const trackArtist = track.artist || 'Unknown Artist';
                
                queueHtml += `
                    <div class="queue-item ${isCurrent ? 'current' : ''}" data-uri="${track.uri || ''}" data-position="${index}">
                        <div class="queue-item-info">
                            <div class="queue-item-title">${isCurrent ? '▶ ' : ''}${trackTitle}</div>
                            <div class="queue-item-artist">${trackArtist}</div>
                        </div>
                        <div class="queue-item-actions">
                            <button class="queue-action-btn play-track-btn" title="Play Now" data-index="${index}">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="queue-action-btn remove-track-btn" title="Remove" data-position="${index}">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            // Set HTML content
            queueContainer.innerHTML = queueHtml;
            
            // Add event listeners to the queue action buttons
            const playButtons = queueContainer.querySelectorAll('.play-track-btn');
            const removeButtons = queueContainer.querySelectorAll('.remove-track-btn');
            
            // Play track buttons
            playButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const trackUri = this.closest('.queue-item').getAttribute('data-uri');
                    if (trackUri) {
                        playTrackByUri(trackUri);
                    }
                });
            });
            
            // Remove track buttons
            removeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const trackPosition = this.getAttribute('data-position');
                    if (trackPosition) {
                        removeTrackFromQueue(trackPosition);
                    }
                });
            });
        }
        
        // Play a track from the queue by URI
        function playTrackByUri(uri) {
            if (!uri) return;
            
            console.log(`Playing track with URI: ${uri}`);
            sendCommand(`play_uri:${uri}`);
        }
        
        // Remove a track from the queue
        async function removeTrackFromQueue(position) {
            if (position === undefined || position === null) return;
            
            console.log(`Removing track at position: ${position} from queue`);
            
            try {
                await sendCommand(`remove_track:${position}`);
                // Refresh the queue after removing
                setTimeout(fetchQueue, CONFIG.fastUpdateAfterCommand);
            } catch (error) {
                console.error('Error removing track from queue:', error);
            }
        }
        
        // Clear the entire queue
        async function clearQueue() {
            if (!confirm('Are you sure you want to clear the entire queue?')) {
                return;
            }
            
            console.log('Clearing queue');
            
            try {
                await sendCommand('clear_queue');
                // Refresh the queue after clearing
                setTimeout(fetchQueue, CONFIG.fastUpdateAfterCommand);
            } catch (error) {
                console.error('Error clearing queue:', error);
            }
        }
        
        // Call this function when switching players or when capabilities change
        // to update the queue display if needed
        function updateQueueDisplay() {
            // Check if we should show the queue panel
            if (playerCapabilities.hasQueue) {
                queuePanel.style.display = 'block';
                fetchQueue();
            } else {
                queuePanel.style.display = 'none';
            }
        }
    </script>
</body>
</html>