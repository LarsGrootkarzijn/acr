use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::collections::HashMap;

fn main() {
    println!("cargo:rerun-if-changed=secrets.txt");
    println!("cargo:rerun-if-changed=config/secrets.txt");
    println!("cargo:rerun-if-changed=../secrets.txt");

    // Log all secrets found during build
    println!("cargo:warning=SECRETS FOUND DURING BUILD:");

    let mut secrets = HashMap::new();
    // Check for secrets in various possible locations
    check_secrets_file("secrets.txt", &mut secrets);
    check_secrets_file("config/secrets.txt", &mut secrets);
    check_secrets_file("../secrets.txt", &mut secrets);

    // Look for environment variables with secret-like names
    check_environment_secrets(&mut secrets);

    // Generate Rust code with the secrets
    generate_secrets_file(&secrets);
}

fn check_secrets_file(filename: &str, secrets: &mut HashMap<String, String>) {
    let path = Path::new(filename);
    if path.exists() {
        println!("cargo:warning=Found secrets file: {}", path.display());
        if let Ok(file) = File::open(path) {
            let reader = BufReader::new(file);
            let mut count = 0;
            for line in reader.lines() {
                if let Ok(line) = line {
                    let trimmed = line.trim();
                    if trimmed.is_empty() || trimmed.starts_with('#') {
                        continue;
                    }
                    if let Some(pos) = line.find('=') {
                        let key = line[..pos].trim().to_string();
                        let value = line[pos+1..].trim().to_string();
                        secrets.insert(key.clone(), value.clone());
                        let masked_value = mask_value(&value);
                        println!("cargo:warning=Secret: {}={}", key, masked_value);
                        count += 1;
                    }
                }
            }
            println!("cargo:warning=Read {} secrets from {}", count, path.display());
        } else {
            println!("cargo:warning=Failed to open secrets file: {}", path.display());
        }
    }
}

fn check_environment_secrets(secrets: &mut HashMap<String, String>) {
    let secret_prefixes = ["API_", "TOKEN_", "SECRET_", "PASSWORD_", "AUTH_", "CREDENTIAL_", "KEY_"];
    let mut found = false;
    println!("cargo:warning=Checking environment variables for secrets...");
    for (key, value) in env::vars() {
        let upper_key = key.to_uppercase();
        for prefix in &secret_prefixes {
            if upper_key.starts_with(prefix) || upper_key.contains("_SECRET_") || upper_key.contains("_API_KEY") {
                secrets.insert(key.clone(), value.clone());
                let masked_value = mask_value(&value);
                println!("cargo:warning=Environment secret: {}={}", key, masked_value);
                found = true;
            }
        }
    }
    if !found {
        println!("cargo:warning=No environment secrets found with common prefixes");
    }
}

fn generate_secrets_file(secrets: &HashMap<String, String>) {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_secrets.rs");
    let mut content = String::new();
    content.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
    content.push_str("// This file is generated by build.rs\n\n");
    // Common secrets as constants, fallback to "unknown" if not found
    content.push_str(&format!(
        "pub const LASTFM_API_KEY: &str = \"{}\";\n",
        secrets.get("LASTFM_APIKEY").map(|s| s.as_str()).unwrap_or("unknown")
    ));
    content.push_str(&format!(
        "pub const LASTFM_API_SECRET: &str = \"{}\";\n",
        secrets.get("LASTFM_APISECRET").map(|s| s.as_str()).unwrap_or("unknown")
    ));
    content.push_str(&format!(
        "pub const ARTISTDB_API_KEY: &str = \"{}\";\n",
        secrets.get("ARTISTDB_APIKEY").map(|s| s.as_str()).unwrap_or("unknown")
    ));
    content.push_str(&format!(
        "pub const SECRETS_ENCRYPTION_KEY: &str = \"{}\";\n",
        secrets.get("SECRETS_ENCRYPTION_KEY").map(|s| s.as_str()).unwrap_or("unknown")
    ));
    // All secrets as a HashMap
    content.push_str("\npub fn get_all_secrets() -> std::collections::HashMap<String, String> {\n");
    content.push_str("    let mut map = std::collections::HashMap::new();\n");
    for (key, value) in secrets {
        content.push_str(&format!("    map.insert(\"{}\".to_string(), \"{}\".to_string());\n", key, value));
    }
    content.push_str("    map\n}\n");
    fs::write(&dest_path, content).unwrap();
    println!("cargo:warning=Generated secrets file at: {}", dest_path.display());
    println!("cargo:rerun-if-changed=build.rs");
}

fn mask_value(value: &str) -> String {
    if value.len() <= 3 {
        return "***".to_string();
    }
    format!("{}***", &value[0..3])
}